{"version":3,"sources":["../src/core/index.ts","../src/shared/constants.ts","../src/shared/utils.ts","../src/core/mojang-api.ts","../src/core/skin-parser.ts","../src/core/renderer.ts"],"sourcesContent":["/**\n * Core Avatar Generation\n */\n\nimport type { AvatarOptions, AvatarResult } from '../shared/types';\nimport { DEFAULT_OPTIONS } from '../shared/constants';\nimport { validateUuid } from '../shared/utils';\nimport { fetchMojangProfile, extractSkinInfo, fetchSkinTexture } from './mojang-api';\nimport { renderAvatar } from './renderer';\n\n/**\n * Generate Minecraft avatar from UUID\n *\n * @param uuid - Minecraft player UUID\n * @param options - Avatar generation options\n * @returns Avatar result with image data\n *\n * @example\n * ```typescript\n * import { generateAvatar } from '@bafv4/mcavatar';\n *\n * const result = await generateAvatar('uuid-here', { size: 64 });\n * // result.data is a Buffer containing PNG image\n * ```\n */\nexport async function generateAvatar(\n  uuid: string,\n  options: AvatarOptions = {}\n): Promise<AvatarResult> {\n  const opts = { ...DEFAULT_OPTIONS, ...options };\n\n  try {\n    // Fetch skin from Mojang API\n    const cleanUuid = validateUuid(uuid);\n    const profile = await fetchMojangProfile(cleanUuid);\n    const skinInfo = extractSkinInfo(profile);\n    const skinBuffer = await fetchSkinTexture(skinInfo.skinUrl);\n\n    return await renderAvatar(skinBuffer, opts);\n  } catch (error) {\n    // Use fallback if enabled and different from requested UUID\n    if (opts.fallbackUuid && opts.fallbackUuid !== uuid) {\n      try {\n        const fallbackProfile = await fetchMojangProfile(opts.fallbackUuid);\n        const fallbackSkinInfo = extractSkinInfo(fallbackProfile);\n        const fallbackSkinBuffer = await fetchSkinTexture(fallbackSkinInfo.skinUrl);\n\n        const result = await renderAvatar(fallbackSkinBuffer, opts);\n        return { ...result, usedFallback: true };\n      } catch {\n        // Re-throw original error if fallback also fails\n        throw error;\n      }\n    }\n\n    throw error;\n  }\n}\n\n// Re-export types and utilities\nexport type { AvatarOptions, AvatarResult, SkinFormat, MinecraftAvatarProps } from '../shared/types';\nexport { STEVE_UUID, DEFAULT_OPTIONS } from '../shared/constants';\nexport { validateUuid, formatUuid } from '../shared/utils';\n","/**\n * Minecraft Avatar Constants\n */\n\nimport type { AvatarOptions, SkinRegion } from './types';\n\n/**\n * Steve's UUID for fallback\n */\nexport const STEVE_UUID = '8667ba71b85a4004af54457a9734eed7';\n\n/**\n * Mojang API endpoints\n */\nexport const MOJANG_API = {\n  SESSION_SERVER: 'https://sessionserver.mojang.com/session/minecraft/profile',\n} as const;\n\n/**\n * Skin texture dimensions\n */\nexport const SKIN_DIMENSIONS = {\n  LEGACY: { width: 64, height: 32 },\n  MODERN: { width: 64, height: 64 },\n} as const;\n\n/**\n * Head region coordinates (8x8 pixels)\n */\nexport const HEAD_REGIONS: {\n  BASE: SkinRegion;\n  OVERLAY: SkinRegion;\n} = {\n  /** Base head layer */\n  BASE: { x: 8, y: 8, width: 8, height: 8 },\n  /** Overlay/hat layer (modern skins only) */\n  OVERLAY: { x: 40, y: 8, width: 8, height: 8 },\n};\n\n/**\n * Default avatar options\n */\nexport const DEFAULT_OPTIONS: Required<AvatarOptions> = {\n  size: 64,\n  includeOverlay: true,\n  fallbackUuid: STEVE_UUID,\n};\n","/**\n * Minecraft Avatar Utilities\n */\n\n/**\n * Validate and normalize UUID format\n * Removes hyphens and validates the format\n */\nexport function validateUuid(uuid: string): string {\n  // Remove hyphens\n  const cleanUuid = uuid.replace(/-/g, '');\n\n  // Validate format (32 hex characters)\n  if (!/^[0-9a-f]{32}$/i.test(cleanUuid)) {\n    throw new Error(`Invalid UUID format: ${uuid}`);\n  }\n\n  return cleanUuid;\n}\n\n/**\n * Format UUID with hyphens (8-4-4-4-12)\n */\nexport function formatUuid(uuid: string): string {\n  const clean = validateUuid(uuid);\n  return [\n    clean.slice(0, 8),\n    clean.slice(8, 12),\n    clean.slice(12, 16),\n    clean.slice(16, 20),\n    clean.slice(20, 32),\n  ].join('-');\n}\n","/**\n * Mojang API Client\n */\n\nimport type { MojangProfile, SkinTextureInfo } from '../shared/types';\nimport { MOJANG_API } from '../shared/constants';\nimport { validateUuid } from '../shared/utils';\n\n/**\n * Fetch player profile from Mojang Session Server\n */\nexport async function fetchMojangProfile(uuid: string): Promise<MojangProfile> {\n  const cleanUuid = validateUuid(uuid);\n  const url = `${MOJANG_API.SESSION_SERVER}/${cleanUuid}`;\n\n  const response = await fetch(url, {\n    cache: 'force-cache',\n  });\n\n  if (!response.ok) {\n    throw new Error(`Mojang API error: ${response.status}`);\n  }\n\n  const profile: MojangProfile = await response.json();\n  return profile;\n}\n\n/**\n * Extract skin texture info from profile\n */\nexport function extractSkinInfo(profile: MojangProfile): SkinTextureInfo {\n  const textureProperty = profile.properties.find((p) => p.name === 'textures');\n\n  if (!textureProperty) {\n    throw new Error('No textures property found in profile');\n  }\n\n  // Decode base64 texture data\n  const textureData = JSON.parse(\n    Buffer.from(textureProperty.value, 'base64').toString('utf-8')\n  );\n\n  const skinData = textureData.textures?.SKIN;\n  if (!skinData?.url) {\n    throw new Error('No skin URL found in texture data');\n  }\n\n  return {\n    skinUrl: skinData.url,\n    isSlim: skinData.metadata?.model === 'slim',\n    capeUrl: textureData.textures?.CAPE?.url,\n  };\n}\n\n/**\n * Fetch skin texture as ArrayBuffer\n */\nexport async function fetchSkinTexture(skinUrl: string): Promise<ArrayBuffer> {\n  const response = await fetch(skinUrl, {\n    cache: 'force-cache',\n  });\n\n  if (!response.ok) {\n    throw new Error(`Failed to fetch skin: ${response.status}`);\n  }\n\n  return await response.arrayBuffer();\n}\n","/**\n * Skin Texture Parser\n */\n\nimport type { SkinFormat, SkinRegion } from '../shared/types';\nimport { HEAD_REGIONS, SKIN_DIMENSIONS } from '../shared/constants';\n\n/**\n * Detect skin format from dimensions\n */\nexport function detectSkinFormat(width: number, height: number): SkinFormat {\n  if (\n    width === SKIN_DIMENSIONS.MODERN.width &&\n    height === SKIN_DIMENSIONS.MODERN.height\n  ) {\n    return 'modern';\n  }\n  if (\n    width === SKIN_DIMENSIONS.LEGACY.width &&\n    height === SKIN_DIMENSIONS.LEGACY.height\n  ) {\n    return 'legacy';\n  }\n  throw new Error(`Unexpected skin dimensions: ${width}x${height}`);\n}\n\n/**\n * Check if overlay layer has visible pixels\n * @param pixelData RGBA pixel data (4 bytes per pixel)\n */\nexport function hasVisibleOverlay(pixelData: Uint8Array | Buffer): boolean {\n  // Check every 4th byte (alpha channel)\n  for (let i = 3; i < pixelData.length; i += 4) {\n    if (pixelData[i] > 0) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * Get head region coordinates\n */\nexport function getBaseHeadRegion(): SkinRegion {\n  return { ...HEAD_REGIONS.BASE };\n}\n\n/**\n * Get overlay region coordinates\n */\nexport function getOverlayHeadRegion(): SkinRegion {\n  return { ...HEAD_REGIONS.OVERLAY };\n}\n","/**\n * Avatar Renderer using Sharp\n */\n\nimport type { AvatarOptions, AvatarResult, SkinFormat } from '../shared/types';\nimport { DEFAULT_OPTIONS } from '../shared/constants';\nimport {\n  detectSkinFormat,\n  hasVisibleOverlay,\n  getBaseHeadRegion,\n  getOverlayHeadRegion,\n} from './skin-parser';\n\n/**\n * Render avatar from skin buffer using Sharp\n */\nexport async function renderAvatar(\n  skinBuffer: ArrayBuffer,\n  options: AvatarOptions = {}\n): Promise<AvatarResult> {\n  const sharp = (await import('sharp')).default;\n  const opts = { ...DEFAULT_OPTIONS, ...options };\n\n  const skinImage = sharp(Buffer.from(skinBuffer));\n  const metadata = await skinImage.metadata();\n\n  if (!metadata.width || !metadata.height) {\n    throw new Error('Invalid skin texture: missing dimensions');\n  }\n\n  const skinFormat: SkinFormat = detectSkinFormat(metadata.width, metadata.height);\n  const hasModernOverlay = skinFormat === 'modern' && opts.includeOverlay;\n\n  // Extract base head (8x8)\n  const baseRegion = getBaseHeadRegion();\n  const baseHead = await sharp(Buffer.from(skinBuffer))\n    .extract({\n      left: baseRegion.x,\n      top: baseRegion.y,\n      width: baseRegion.width,\n      height: baseRegion.height,\n    })\n    .toBuffer();\n\n  let hasOverlay = false;\n  let finalHead: Buffer;\n\n  if (hasModernOverlay) {\n    // Extract overlay head (8x8)\n    const overlayRegion = getOverlayHeadRegion();\n    const overlayHead = await sharp(Buffer.from(skinBuffer))\n      .extract({\n        left: overlayRegion.x,\n        top: overlayRegion.y,\n        width: overlayRegion.width,\n        height: overlayRegion.height,\n      })\n      .toBuffer();\n\n    // Check if overlay has visible pixels\n    const overlayData = await sharp(overlayHead)\n      .ensureAlpha()\n      .raw()\n      .toBuffer();\n\n    hasOverlay = hasVisibleOverlay(overlayData);\n\n    if (hasOverlay) {\n      // Composite base (slightly smaller) with overlay\n      const baseSize = Math.round(opts.size * 0.925);\n      const baseOffset = Math.round((opts.size - baseSize) / 2);\n\n      const resizedBase = await sharp(baseHead)\n        .resize(baseSize, baseSize, { kernel: 'nearest' })\n        .png()\n        .toBuffer();\n\n      const resizedOverlay = await sharp(overlayHead)\n        .resize(opts.size, opts.size, { kernel: 'nearest' })\n        .png()\n        .toBuffer();\n\n      finalHead = await sharp({\n        create: {\n          width: opts.size,\n          height: opts.size,\n          channels: 4,\n          background: { r: 0, g: 0, b: 0, alpha: 0 },\n        },\n      })\n        .composite([\n          { input: resizedBase, top: baseOffset, left: baseOffset },\n          { input: resizedOverlay, top: 0, left: 0 },\n        ])\n        .png()\n        .toBuffer();\n    } else {\n      // No visible overlay, just resize base\n      finalHead = await sharp(baseHead)\n        .resize(opts.size, opts.size, { kernel: 'nearest' })\n        .png()\n        .toBuffer();\n    }\n  } else {\n    // Legacy skin or overlay disabled\n    finalHead = await sharp(baseHead)\n      .resize(opts.size, opts.size, { kernel: 'nearest' })\n      .png()\n      .toBuffer();\n  }\n\n  return {\n    data: finalHead,\n    contentType: 'image/png',\n    usedFallback: false,\n    skinFormat,\n    hasOverlay,\n  };\n}\n"],"mappings":"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","names":[]}