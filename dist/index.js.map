{"version":3,"sources":["../src/shared/constants.ts","../src/shared/utils.ts","../src/core/mojang-api.ts","../src/core/skin-parser.ts","../src/core/renderer.ts","../src/3d/geometry.ts","../src/3d/poses.ts","../src/3d/projection.ts","../src/3d/texture-mapper.ts","../src/core/renderer-3d.ts","../src/core/index.ts"],"sourcesContent":["/**\n * Minecraft Avatar Constants\n */\n\nimport type {\n  AvatarOptions,\n  SkinRegion,\n  FullBodyOptions,\n  BodyPartLayerRegions,\n  ArmRegions,\n  ViewConfig,\n  Vector3,\n} from './types';\n\n/**\n * Steve's UUID for fallback\n */\nexport const STEVE_UUID = '8667ba71b85a4004af54457a9734eed7';\n\n/**\n * Mojang API endpoints\n */\nexport const MOJANG_API = {\n  SESSION_SERVER: 'https://sessionserver.mojang.com/session/minecraft/profile',\n} as const;\n\n/**\n * Skin texture dimensions\n */\nexport const SKIN_DIMENSIONS = {\n  LEGACY: { width: 64, height: 32 },\n  MODERN: { width: 64, height: 64 },\n} as const;\n\n/**\n * Head region coordinates (8x8 pixels)\n */\nexport const HEAD_REGIONS: {\n  BASE: SkinRegion;\n  OVERLAY: SkinRegion;\n} = {\n  /** Base head layer */\n  BASE: { x: 8, y: 8, width: 8, height: 8 },\n  /** Overlay/hat layer (modern skins only) */\n  OVERLAY: { x: 40, y: 8, width: 8, height: 8 },\n};\n\n/**\n * Default avatar options\n */\nexport const DEFAULT_OPTIONS: Required<AvatarOptions> = {\n  size: 64,\n  includeOverlay: true,\n  fallbackUuid: STEVE_UUID,\n};\n\n// ============================================================\n// 3D Full Body Constants\n// ============================================================\n\n/**\n * Body part skin regions for 64x64 modern skins\n * Each body part has base and overlay layers\n * Each layer has 6 faces: front, back, left, right, top, bottom\n */\nexport const BODY_REGIONS = {\n  HEAD: {\n    BASE: {\n      right: { x: 0, y: 8, width: 8, height: 8 },\n      front: { x: 8, y: 8, width: 8, height: 8 },\n      left: { x: 16, y: 8, width: 8, height: 8 },\n      back: { x: 24, y: 8, width: 8, height: 8 },\n      top: { x: 8, y: 0, width: 8, height: 8 },\n      bottom: { x: 16, y: 0, width: 8, height: 8 },\n    },\n    OVERLAY: {\n      right: { x: 32, y: 8, width: 8, height: 8 },\n      front: { x: 40, y: 8, width: 8, height: 8 },\n      left: { x: 48, y: 8, width: 8, height: 8 },\n      back: { x: 56, y: 8, width: 8, height: 8 },\n      top: { x: 40, y: 0, width: 8, height: 8 },\n      bottom: { x: 48, y: 0, width: 8, height: 8 },\n    },\n  } as BodyPartLayerRegions,\n\n  TORSO: {\n    BASE: {\n      right: { x: 16, y: 20, width: 4, height: 12 },\n      front: { x: 20, y: 20, width: 8, height: 12 },\n      left: { x: 28, y: 20, width: 4, height: 12 },\n      back: { x: 32, y: 20, width: 8, height: 12 },\n      top: { x: 20, y: 16, width: 8, height: 4 },\n      bottom: { x: 28, y: 16, width: 8, height: 4 },\n    },\n    OVERLAY: {\n      right: { x: 16, y: 36, width: 4, height: 12 },\n      front: { x: 20, y: 36, width: 8, height: 12 },\n      left: { x: 28, y: 36, width: 4, height: 12 },\n      back: { x: 32, y: 36, width: 8, height: 12 },\n      top: { x: 20, y: 32, width: 8, height: 4 },\n      bottom: { x: 28, y: 32, width: 8, height: 4 },\n    },\n  } as BodyPartLayerRegions,\n\n  RIGHT_ARM: {\n    CLASSIC: {\n      BASE: {\n        right: { x: 40, y: 20, width: 4, height: 12 },\n        front: { x: 44, y: 20, width: 4, height: 12 },\n        left: { x: 48, y: 20, width: 4, height: 12 },\n        back: { x: 52, y: 20, width: 4, height: 12 },\n        top: { x: 44, y: 16, width: 4, height: 4 },\n        bottom: { x: 48, y: 16, width: 4, height: 4 },\n      },\n      OVERLAY: {\n        right: { x: 40, y: 36, width: 4, height: 12 },\n        front: { x: 44, y: 36, width: 4, height: 12 },\n        left: { x: 48, y: 36, width: 4, height: 12 },\n        back: { x: 52, y: 36, width: 4, height: 12 },\n        top: { x: 44, y: 32, width: 4, height: 4 },\n        bottom: { x: 48, y: 32, width: 4, height: 4 },\n      },\n    },\n    SLIM: {\n      BASE: {\n        right: { x: 40, y: 20, width: 4, height: 12 },\n        front: { x: 44, y: 20, width: 3, height: 12 },\n        left: { x: 47, y: 20, width: 4, height: 12 },\n        back: { x: 51, y: 20, width: 3, height: 12 },\n        top: { x: 44, y: 16, width: 3, height: 4 },\n        bottom: { x: 47, y: 16, width: 3, height: 4 },\n      },\n      OVERLAY: {\n        right: { x: 40, y: 36, width: 4, height: 12 },\n        front: { x: 44, y: 36, width: 3, height: 12 },\n        left: { x: 47, y: 36, width: 4, height: 12 },\n        back: { x: 51, y: 36, width: 3, height: 12 },\n        top: { x: 44, y: 32, width: 3, height: 4 },\n        bottom: { x: 47, y: 32, width: 3, height: 4 },\n      },\n    },\n  } as ArmRegions,\n\n  LEFT_ARM: {\n    CLASSIC: {\n      BASE: {\n        right: { x: 32, y: 52, width: 4, height: 12 },\n        front: { x: 36, y: 52, width: 4, height: 12 },\n        left: { x: 40, y: 52, width: 4, height: 12 },\n        back: { x: 44, y: 52, width: 4, height: 12 },\n        top: { x: 36, y: 48, width: 4, height: 4 },\n        bottom: { x: 40, y: 48, width: 4, height: 4 },\n      },\n      OVERLAY: {\n        right: { x: 48, y: 52, width: 4, height: 12 },\n        front: { x: 52, y: 52, width: 4, height: 12 },\n        left: { x: 56, y: 52, width: 4, height: 12 },\n        back: { x: 60, y: 52, width: 4, height: 12 },\n        top: { x: 52, y: 48, width: 4, height: 4 },\n        bottom: { x: 56, y: 48, width: 4, height: 4 },\n      },\n    },\n    SLIM: {\n      BASE: {\n        right: { x: 32, y: 52, width: 4, height: 12 },\n        front: { x: 36, y: 52, width: 3, height: 12 },\n        left: { x: 39, y: 52, width: 4, height: 12 },\n        back: { x: 43, y: 52, width: 3, height: 12 },\n        top: { x: 36, y: 48, width: 3, height: 4 },\n        bottom: { x: 39, y: 48, width: 3, height: 4 },\n      },\n      OVERLAY: {\n        right: { x: 48, y: 52, width: 4, height: 12 },\n        front: { x: 52, y: 52, width: 3, height: 12 },\n        left: { x: 55, y: 52, width: 4, height: 12 },\n        back: { x: 59, y: 52, width: 3, height: 12 },\n        top: { x: 52, y: 48, width: 3, height: 4 },\n        bottom: { x: 55, y: 48, width: 3, height: 4 },\n      },\n    },\n  } as ArmRegions,\n\n  RIGHT_LEG: {\n    BASE: {\n      right: { x: 0, y: 20, width: 4, height: 12 },\n      front: { x: 4, y: 20, width: 4, height: 12 },\n      left: { x: 8, y: 20, width: 4, height: 12 },\n      back: { x: 12, y: 20, width: 4, height: 12 },\n      top: { x: 4, y: 16, width: 4, height: 4 },\n      bottom: { x: 8, y: 16, width: 4, height: 4 },\n    },\n    OVERLAY: {\n      right: { x: 0, y: 36, width: 4, height: 12 },\n      front: { x: 4, y: 36, width: 4, height: 12 },\n      left: { x: 8, y: 36, width: 4, height: 12 },\n      back: { x: 12, y: 36, width: 4, height: 12 },\n      top: { x: 4, y: 32, width: 4, height: 4 },\n      bottom: { x: 8, y: 32, width: 4, height: 4 },\n    },\n  } as BodyPartLayerRegions,\n\n  LEFT_LEG: {\n    BASE: {\n      right: { x: 16, y: 52, width: 4, height: 12 },\n      front: { x: 20, y: 52, width: 4, height: 12 },\n      left: { x: 24, y: 52, width: 4, height: 12 },\n      back: { x: 28, y: 52, width: 4, height: 12 },\n      top: { x: 20, y: 48, width: 4, height: 4 },\n      bottom: { x: 24, y: 48, width: 4, height: 4 },\n    },\n    OVERLAY: {\n      right: { x: 0, y: 52, width: 4, height: 12 },\n      front: { x: 4, y: 52, width: 4, height: 12 },\n      left: { x: 8, y: 52, width: 4, height: 12 },\n      back: { x: 12, y: 52, width: 4, height: 12 },\n      top: { x: 4, y: 48, width: 4, height: 4 },\n      bottom: { x: 8, y: 48, width: 4, height: 4 },\n    },\n  } as BodyPartLayerRegions,\n} as const;\n\n/**\n * Model dimensions in Minecraft units (1 unit = 1 pixel on skin)\n */\nexport const MODEL_DIMENSIONS = {\n  HEAD: { width: 8, height: 8, depth: 8 },\n  TORSO: { width: 8, height: 12, depth: 4 },\n  ARM_CLASSIC: { width: 4, height: 12, depth: 4 },\n  ARM_SLIM: { width: 3, height: 12, depth: 4 },\n  LEG: { width: 4, height: 12, depth: 4 },\n} as const;\n\n/**\n * Body part positions relative to model origin (center at torso bottom)\n * Y-axis points up, origin at feet level center\n */\nexport const BODY_POSITIONS: Record<string, Vector3> = {\n  HEAD: { x: 0, y: 24, z: 0 },\n  TORSO: { x: 0, y: 18, z: 0 },\n  LEFT_ARM: { x: 6, y: 22, z: 0 },\n  RIGHT_ARM: { x: -6, y: 22, z: 0 },\n  LEFT_LEG: { x: 2, y: 6, z: 0 },\n  RIGHT_LEG: { x: -2, y: 6, z: 0 },\n};\n\n/**\n * Pivot points for rotation (relative to body part position)\n */\nexport const PIVOT_POINTS: Record<string, Vector3> = {\n  HEAD: { x: 0, y: -4, z: 0 },\n  TORSO: { x: 0, y: 0, z: 0 },\n  LEFT_ARM: { x: -2, y: 4, z: 0 },\n  RIGHT_ARM: { x: 2, y: 4, z: 0 },\n  LEFT_LEG: { x: 0, y: 6, z: 0 },\n  RIGHT_LEG: { x: 0, y: 6, z: 0 },\n};\n\n/**\n * Default view configuration\n */\nexport const DEFAULT_VIEW: ViewConfig = {\n  angle: 25,\n  elevation: 10,\n  zoom: 1.0,\n};\n\n/**\n * Default full body rendering options\n */\nexport const DEFAULT_FULLBODY_OPTIONS: Required<\n  Omit<FullBodyOptions, 'armModel' | 'pose'>\n> & { pose: 'standing' } = {\n  width: 300,\n  height: 400,\n  includeOverlay: true,\n  pose: 'standing',\n  view: DEFAULT_VIEW,\n  background: null,\n  fallbackUuid: STEVE_UUID,\n  shadow: false,\n};\n","/**\n * Minecraft Avatar Utilities\n */\n\n/**\n * Validate and normalize UUID format\n * Removes hyphens and validates the format\n */\nexport function validateUuid(uuid: string): string {\n  // Remove hyphens\n  const cleanUuid = uuid.replace(/-/g, '');\n\n  // Validate format (32 hex characters)\n  if (!/^[0-9a-f]{32}$/i.test(cleanUuid)) {\n    throw new Error(`Invalid UUID format: ${uuid}`);\n  }\n\n  return cleanUuid;\n}\n\n/**\n * Format UUID with hyphens (8-4-4-4-12)\n */\nexport function formatUuid(uuid: string): string {\n  const clean = validateUuid(uuid);\n  return [\n    clean.slice(0, 8),\n    clean.slice(8, 12),\n    clean.slice(12, 16),\n    clean.slice(16, 20),\n    clean.slice(20, 32),\n  ].join('-');\n}\n","/**\n * Mojang API Client\n */\n\nimport type { MojangProfile, SkinTextureInfo } from '../shared/types';\nimport { MOJANG_API } from '../shared/constants';\nimport { validateUuid } from '../shared/utils';\n\n/**\n * Fetch player profile from Mojang Session Server\n */\nexport async function fetchMojangProfile(uuid: string): Promise<MojangProfile> {\n  const cleanUuid = validateUuid(uuid);\n  const url = `${MOJANG_API.SESSION_SERVER}/${cleanUuid}`;\n\n  const response = await fetch(url, {\n    cache: 'force-cache',\n  });\n\n  if (!response.ok) {\n    throw new Error(`Mojang API error: ${response.status}`);\n  }\n\n  const profile: MojangProfile = await response.json();\n  return profile;\n}\n\n/**\n * Extract skin texture info from profile\n */\nexport function extractSkinInfo(profile: MojangProfile): SkinTextureInfo {\n  const textureProperty = profile.properties.find((p) => p.name === 'textures');\n\n  if (!textureProperty) {\n    throw new Error('No textures property found in profile');\n  }\n\n  // Decode base64 texture data\n  const textureData = JSON.parse(\n    Buffer.from(textureProperty.value, 'base64').toString('utf-8')\n  );\n\n  const skinData = textureData.textures?.SKIN;\n  if (!skinData?.url) {\n    throw new Error('No skin URL found in texture data');\n  }\n\n  return {\n    skinUrl: skinData.url,\n    isSlim: skinData.metadata?.model === 'slim',\n    capeUrl: textureData.textures?.CAPE?.url,\n  };\n}\n\n/**\n * Fetch skin texture as ArrayBuffer\n */\nexport async function fetchSkinTexture(skinUrl: string): Promise<ArrayBuffer> {\n  const response = await fetch(skinUrl, {\n    cache: 'force-cache',\n  });\n\n  if (!response.ok) {\n    throw new Error(`Failed to fetch skin: ${response.status}`);\n  }\n\n  return await response.arrayBuffer();\n}\n","/**\n * Skin Texture Parser\n */\n\nimport type { SkinFormat, SkinRegion } from '../shared/types';\nimport { HEAD_REGIONS, SKIN_DIMENSIONS } from '../shared/constants';\n\n/**\n * Detect skin format from dimensions\n */\nexport function detectSkinFormat(width: number, height: number): SkinFormat {\n  if (\n    width === SKIN_DIMENSIONS.MODERN.width &&\n    height === SKIN_DIMENSIONS.MODERN.height\n  ) {\n    return 'modern';\n  }\n  if (\n    width === SKIN_DIMENSIONS.LEGACY.width &&\n    height === SKIN_DIMENSIONS.LEGACY.height\n  ) {\n    return 'legacy';\n  }\n  throw new Error(`Unexpected skin dimensions: ${width}x${height}`);\n}\n\n/**\n * Check if overlay layer has visible pixels\n * @param pixelData RGBA pixel data (4 bytes per pixel)\n */\nexport function hasVisibleOverlay(pixelData: Uint8Array | Buffer): boolean {\n  // Check every 4th byte (alpha channel)\n  for (let i = 3; i < pixelData.length; i += 4) {\n    if (pixelData[i] > 0) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * Get head region coordinates\n */\nexport function getBaseHeadRegion(): SkinRegion {\n  return { ...HEAD_REGIONS.BASE };\n}\n\n/**\n * Get overlay region coordinates\n */\nexport function getOverlayHeadRegion(): SkinRegion {\n  return { ...HEAD_REGIONS.OVERLAY };\n}\n","/**\n * Avatar Renderer using Sharp\n */\n\nimport type { AvatarOptions, AvatarResult, SkinFormat } from '../shared/types';\nimport { DEFAULT_OPTIONS } from '../shared/constants';\nimport {\n  detectSkinFormat,\n  hasVisibleOverlay,\n  getBaseHeadRegion,\n  getOverlayHeadRegion,\n} from './skin-parser';\n\n/**\n * Render avatar from skin buffer using Sharp\n */\nexport async function renderAvatar(\n  skinBuffer: ArrayBuffer,\n  options: AvatarOptions = {}\n): Promise<AvatarResult> {\n  const sharp = (await import('sharp')).default;\n  const opts = { ...DEFAULT_OPTIONS, ...options };\n\n  const skinImage = sharp(Buffer.from(skinBuffer));\n  const metadata = await skinImage.metadata();\n\n  if (!metadata.width || !metadata.height) {\n    throw new Error('Invalid skin texture: missing dimensions');\n  }\n\n  const skinFormat: SkinFormat = detectSkinFormat(metadata.width, metadata.height);\n  const hasModernOverlay = skinFormat === 'modern' && opts.includeOverlay;\n\n  // Extract base head (8x8)\n  const baseRegion = getBaseHeadRegion();\n  const baseHead = await sharp(Buffer.from(skinBuffer))\n    .extract({\n      left: baseRegion.x,\n      top: baseRegion.y,\n      width: baseRegion.width,\n      height: baseRegion.height,\n    })\n    .toBuffer();\n\n  let hasOverlay = false;\n  let finalHead: Buffer;\n\n  if (hasModernOverlay) {\n    // Extract overlay head (8x8)\n    const overlayRegion = getOverlayHeadRegion();\n    const overlayHead = await sharp(Buffer.from(skinBuffer))\n      .extract({\n        left: overlayRegion.x,\n        top: overlayRegion.y,\n        width: overlayRegion.width,\n        height: overlayRegion.height,\n      })\n      .toBuffer();\n\n    // Check if overlay has visible pixels\n    const overlayData = await sharp(overlayHead)\n      .ensureAlpha()\n      .raw()\n      .toBuffer();\n\n    hasOverlay = hasVisibleOverlay(overlayData);\n\n    if (hasOverlay) {\n      // Composite base (slightly smaller) with overlay\n      const baseSize = Math.round(opts.size * 0.925);\n      const baseOffset = Math.round((opts.size - baseSize) / 2);\n\n      const resizedBase = await sharp(baseHead)\n        .resize(baseSize, baseSize, { kernel: 'nearest' })\n        .png()\n        .toBuffer();\n\n      const resizedOverlay = await sharp(overlayHead)\n        .resize(opts.size, opts.size, { kernel: 'nearest' })\n        .png()\n        .toBuffer();\n\n      finalHead = await sharp({\n        create: {\n          width: opts.size,\n          height: opts.size,\n          channels: 4,\n          background: { r: 0, g: 0, b: 0, alpha: 0 },\n        },\n      })\n        .composite([\n          { input: resizedBase, top: baseOffset, left: baseOffset },\n          { input: resizedOverlay, top: 0, left: 0 },\n        ])\n        .png()\n        .toBuffer();\n    } else {\n      // No visible overlay, just resize base\n      finalHead = await sharp(baseHead)\n        .resize(opts.size, opts.size, { kernel: 'nearest' })\n        .png()\n        .toBuffer();\n    }\n  } else {\n    // Legacy skin or overlay disabled\n    finalHead = await sharp(baseHead)\n      .resize(opts.size, opts.size, { kernel: 'nearest' })\n      .png()\n      .toBuffer();\n  }\n\n  return {\n    data: finalHead,\n    contentType: 'image/png',\n    usedFallback: false,\n    skinFormat,\n    hasOverlay,\n  };\n}\n","/**\n * Body Part Geometry Definitions\n */\n\nimport type {\n  Vector3,\n  BodyPart,\n  ArmModel,\n  CubeFace,\n  FaceName,\n  SkinRegion,\n  BodyPartFaceRegions,\n} from '../shared/types';\nimport {\n  BODY_REGIONS,\n  MODEL_DIMENSIONS,\n  BODY_POSITIONS,\n  PIVOT_POINTS,\n} from '../shared/constants';\n\n/**\n * Create vertices for a cube face\n * Vertices are ordered: [top-left, top-right, bottom-right, bottom-left]\n * This ordering matches the UV coordinate system where:\n * - U increases left to right (0 to 1)\n * - V increases top to bottom (0 to 1)\n *\n * Minecraft skin textures have Y=0 at top, so our UV mapping:\n * - top-left = (0, 0)\n * - top-right = (1, 0)\n * - bottom-right = (1, 1)\n * - bottom-left = (0, 1)\n */\nfunction createFaceVertices(\n  center: Vector3,\n  size: Vector3,\n  face: FaceName\n): [Vector3, Vector3, Vector3, Vector3] {\n  const hw = size.x / 2; // half width\n  const hh = size.y / 2; // half height\n  const hd = size.z / 2; // half depth\n\n  // Face vertices are ordered to match texture UV coordinates\n  // When looking at the face from outside:\n  // - Vertex 0: top-left of texture -> maps to UV (0,0)\n  // - Vertex 1: top-right of texture -> maps to UV (1,0)\n  // - Vertex 2: bottom-right of texture -> maps to UV (1,1)\n  // - Vertex 3: bottom-left of texture -> maps to UV (0,1)\n\n  switch (face) {\n    case 'front':\n      // Looking at front face (+Z direction), texture left is -X\n      return [\n        { x: center.x - hw, y: center.y + hh, z: center.z + hd }, // top-left\n        { x: center.x + hw, y: center.y + hh, z: center.z + hd }, // top-right\n        { x: center.x + hw, y: center.y - hh, z: center.z + hd }, // bottom-right\n        { x: center.x - hw, y: center.y - hh, z: center.z + hd }, // bottom-left\n      ];\n    case 'back':\n      // Looking at back face (-Z direction), texture left is +X\n      return [\n        { x: center.x + hw, y: center.y + hh, z: center.z - hd }, // top-left\n        { x: center.x - hw, y: center.y + hh, z: center.z - hd }, // top-right\n        { x: center.x - hw, y: center.y - hh, z: center.z - hd }, // bottom-right\n        { x: center.x + hw, y: center.y - hh, z: center.z - hd }, // bottom-left\n      ];\n    case 'left':\n      // Looking at left face (-X direction), texture left is -Z\n      return [\n        { x: center.x - hw, y: center.y + hh, z: center.z - hd }, // top-left\n        { x: center.x - hw, y: center.y + hh, z: center.z + hd }, // top-right\n        { x: center.x - hw, y: center.y - hh, z: center.z + hd }, // bottom-right\n        { x: center.x - hw, y: center.y - hh, z: center.z - hd }, // bottom-left\n      ];\n    case 'right':\n      // Looking at right face (+X direction), texture left is +Z\n      return [\n        { x: center.x + hw, y: center.y + hh, z: center.z + hd }, // top-left\n        { x: center.x + hw, y: center.y + hh, z: center.z - hd }, // top-right\n        { x: center.x + hw, y: center.y - hh, z: center.z - hd }, // bottom-right\n        { x: center.x + hw, y: center.y - hh, z: center.z + hd }, // bottom-left\n      ];\n    case 'top':\n      // Looking at top face (+Y direction) from above, texture top is -Z (back)\n      return [\n        { x: center.x - hw, y: center.y + hh, z: center.z - hd }, // top-left (back-left)\n        { x: center.x + hw, y: center.y + hh, z: center.z - hd }, // top-right (back-right)\n        { x: center.x + hw, y: center.y + hh, z: center.z + hd }, // bottom-right (front-right)\n        { x: center.x - hw, y: center.y + hh, z: center.z + hd }, // bottom-left (front-left)\n      ];\n    case 'bottom':\n      // Looking at bottom face (-Y direction) from below, texture top is +Z (front)\n      return [\n        { x: center.x - hw, y: center.y - hh, z: center.z + hd }, // top-left (front-left)\n        { x: center.x + hw, y: center.y - hh, z: center.z + hd }, // top-right (front-right)\n        { x: center.x + hw, y: center.y - hh, z: center.z - hd }, // bottom-right (back-right)\n        { x: center.x - hw, y: center.y - hh, z: center.z - hd }, // bottom-left (back-left)\n      ];\n  }\n}\n\n/**\n * Get normal vector for a face\n */\nfunction getFaceNormal(face: FaceName): Vector3 {\n  switch (face) {\n    case 'front':\n      return { x: 0, y: 0, z: 1 };\n    case 'back':\n      return { x: 0, y: 0, z: -1 };\n    case 'left':\n      return { x: -1, y: 0, z: 0 };\n    case 'right':\n      return { x: 1, y: 0, z: 0 };\n    case 'top':\n      return { x: 0, y: 1, z: 0 };\n    case 'bottom':\n      return { x: 0, y: -1, z: 0 };\n  }\n}\n\n/**\n * Create a cube face with geometry and UV mapping\n */\nfunction createCubeFace(\n  center: Vector3,\n  size: Vector3,\n  face: FaceName,\n  uv: SkinRegion\n): CubeFace {\n  return {\n    name: face,\n    vertices: createFaceVertices(center, size, face),\n    uv,\n    normal: getFaceNormal(face),\n  };\n}\n\n/**\n * Create all 6 faces for a body part cube\n */\nfunction createBodyPartFaces(\n  center: Vector3,\n  size: Vector3,\n  regions: BodyPartFaceRegions\n): CubeFace[] {\n  const faceNames: FaceName[] = [\n    'front',\n    'back',\n    'left',\n    'right',\n    'top',\n    'bottom',\n  ];\n  return faceNames.map((face) => createCubeFace(center, size, face, regions[face]));\n}\n\n/**\n * Get texture regions for a body part\n */\nexport function getBodyPartRegions(\n  part: BodyPart,\n  layer: 'BASE' | 'OVERLAY',\n  armModel: ArmModel = 'classic'\n): BodyPartFaceRegions {\n  switch (part) {\n    case 'head':\n      return BODY_REGIONS.HEAD[layer];\n    case 'torso':\n      return BODY_REGIONS.TORSO[layer];\n    case 'leftArm':\n      return BODY_REGIONS.LEFT_ARM[armModel === 'slim' ? 'SLIM' : 'CLASSIC'][layer];\n    case 'rightArm':\n      return BODY_REGIONS.RIGHT_ARM[armModel === 'slim' ? 'SLIM' : 'CLASSIC'][layer];\n    case 'leftLeg':\n      return BODY_REGIONS.LEFT_LEG[layer];\n    case 'rightLeg':\n      return BODY_REGIONS.RIGHT_LEG[layer];\n  }\n}\n\n/**\n * Get model dimensions for a body part\n */\nexport function getBodyPartDimensions(\n  part: BodyPart,\n  armModel: ArmModel = 'classic'\n): Vector3 {\n  switch (part) {\n    case 'head':\n      return {\n        x: MODEL_DIMENSIONS.HEAD.width,\n        y: MODEL_DIMENSIONS.HEAD.height,\n        z: MODEL_DIMENSIONS.HEAD.depth,\n      };\n    case 'torso':\n      return {\n        x: MODEL_DIMENSIONS.TORSO.width,\n        y: MODEL_DIMENSIONS.TORSO.height,\n        z: MODEL_DIMENSIONS.TORSO.depth,\n      };\n    case 'leftArm':\n    case 'rightArm':\n      const armDim =\n        armModel === 'slim' ? MODEL_DIMENSIONS.ARM_SLIM : MODEL_DIMENSIONS.ARM_CLASSIC;\n      return {\n        x: armDim.width,\n        y: armDim.height,\n        z: armDim.depth,\n      };\n    case 'leftLeg':\n    case 'rightLeg':\n      return {\n        x: MODEL_DIMENSIONS.LEG.width,\n        y: MODEL_DIMENSIONS.LEG.height,\n        z: MODEL_DIMENSIONS.LEG.depth,\n      };\n  }\n}\n\n/**\n * Get position key for body part\n */\nfunction getPositionKey(part: BodyPart): string {\n  const keyMap: Record<BodyPart, string> = {\n    head: 'HEAD',\n    torso: 'TORSO',\n    leftArm: 'LEFT_ARM',\n    rightArm: 'RIGHT_ARM',\n    leftLeg: 'LEFT_LEG',\n    rightLeg: 'RIGHT_LEG',\n  };\n  return keyMap[part];\n}\n\n/**\n * Get body part position\n */\nexport function getBodyPartPosition(part: BodyPart): Vector3 {\n  const key = getPositionKey(part);\n  return { ...BODY_POSITIONS[key] };\n}\n\n/**\n * Get pivot point for body part rotation\n */\nexport function getBodyPartPivot(part: BodyPart): Vector3 {\n  const key = getPositionKey(part);\n  return { ...PIVOT_POINTS[key] };\n}\n\n/**\n * Create geometry for a body part\n */\nexport interface BodyPartMesh {\n  part: BodyPart;\n  faces: CubeFace[];\n  position: Vector3;\n  pivot: Vector3;\n  size: Vector3;\n  isOverlay: boolean;\n}\n\n/**\n * Create mesh for a body part (base or overlay layer)\n */\nexport function createBodyPartMesh(\n  part: BodyPart,\n  layer: 'BASE' | 'OVERLAY',\n  armModel: ArmModel = 'classic'\n): BodyPartMesh {\n  const size = getBodyPartDimensions(part, armModel);\n  const position = getBodyPartPosition(part);\n  const pivot = getBodyPartPivot(part);\n  const regions = getBodyPartRegions(part, layer, armModel);\n\n  // Create faces centered at origin (will be positioned during rendering)\n  const center: Vector3 = { x: 0, y: 0, z: 0 };\n  const faces = createBodyPartFaces(center, size, regions);\n\n  // Scale overlay slightly larger to prevent z-fighting\n  const overlayScale = layer === 'OVERLAY' ? 1.1 : 1.0;\n  const scaledSize = {\n    x: size.x * overlayScale,\n    y: size.y * overlayScale,\n    z: size.z * overlayScale,\n  };\n\n  return {\n    part,\n    faces:\n      layer === 'OVERLAY'\n        ? createBodyPartFaces(center, scaledSize, regions)\n        : faces,\n    position,\n    pivot,\n    size: layer === 'OVERLAY' ? scaledSize : size,\n    isOverlay: layer === 'OVERLAY',\n  };\n}\n\n/**\n * Create all body part meshes for a character\n */\nexport function createCharacterMeshes(\n  armModel: ArmModel = 'classic',\n  includeOverlay: boolean = true\n): BodyPartMesh[] {\n  const parts: BodyPart[] = [\n    'head',\n    'torso',\n    'leftArm',\n    'rightArm',\n    'leftLeg',\n    'rightLeg',\n  ];\n\n  const meshes: BodyPartMesh[] = [];\n\n  for (const part of parts) {\n    // Add base layer\n    meshes.push(createBodyPartMesh(part, 'BASE', armModel));\n\n    // Add overlay layer if enabled\n    if (includeOverlay) {\n      meshes.push(createBodyPartMesh(part, 'OVERLAY', armModel));\n    }\n  }\n\n  return meshes;\n}\n","/**\n * Predefined Pose Definitions\n */\n\nimport type { PoseDefinition, Rotation3D, BodyPartPose, PoseName } from '../shared/types';\n\n/** Identity rotation (no rotation) */\nconst NO_ROTATION: Rotation3D = { pitch: 0, yaw: 0, roll: 0 };\n\n/** Default body part pose */\nconst DEFAULT_POSE: BodyPartPose = { rotation: NO_ROTATION };\n\n/**\n * Standing pose - default neutral stance\n */\nexport const POSE_STANDING: PoseDefinition = {\n  name: 'standing',\n  head: { rotation: { pitch: 0, yaw: 0, roll: 0 } },\n  torso: DEFAULT_POSE,\n  leftArm: { rotation: { pitch: 0, yaw: 0, roll: 3 } },\n  rightArm: { rotation: { pitch: 0, yaw: 0, roll: -3 } },\n  leftLeg: DEFAULT_POSE,\n  rightLeg: DEFAULT_POSE,\n};\n\n/**\n * Walking pose - mid-stride position\n */\nexport const POSE_WALKING: PoseDefinition = {\n  name: 'walking',\n  head: { rotation: { pitch: 0, yaw: 0, roll: 0 } },\n  torso: DEFAULT_POSE,\n  leftArm: { rotation: { pitch: 30, yaw: 0, roll: 3 } },\n  rightArm: { rotation: { pitch: -30, yaw: 0, roll: -3 } },\n  leftLeg: { rotation: { pitch: -25, yaw: 0, roll: 0 } },\n  rightLeg: { rotation: { pitch: 25, yaw: 0, roll: 0 } },\n};\n\n/**\n * Running pose - extended stride\n */\nexport const POSE_RUNNING: PoseDefinition = {\n  name: 'running',\n  head: { rotation: { pitch: -5, yaw: 0, roll: 0 } },\n  torso: { rotation: { pitch: -10, yaw: 0, roll: 0 } },\n  leftArm: { rotation: { pitch: 50, yaw: 0, roll: 5 } },\n  rightArm: { rotation: { pitch: -50, yaw: 0, roll: -5 } },\n  leftLeg: { rotation: { pitch: -40, yaw: 0, roll: 0 } },\n  rightLeg: { rotation: { pitch: 40, yaw: 0, roll: 0 } },\n};\n\n/**\n * Waving pose - right arm raised\n */\nexport const POSE_WAVING: PoseDefinition = {\n  name: 'waving',\n  head: { rotation: { pitch: 0, yaw: 15, roll: 5 } },\n  torso: DEFAULT_POSE,\n  leftArm: { rotation: { pitch: 0, yaw: 0, roll: 3 } },\n  rightArm: { rotation: { pitch: -120, yaw: 20, roll: -20 } },\n  leftLeg: DEFAULT_POSE,\n  rightLeg: DEFAULT_POSE,\n};\n\n/**\n * Sitting pose\n */\nexport const POSE_SITTING: PoseDefinition = {\n  name: 'sitting',\n  head: { rotation: { pitch: 5, yaw: 0, roll: 0 } },\n  torso: DEFAULT_POSE,\n  leftArm: { rotation: { pitch: -45, yaw: 0, roll: 10 } },\n  rightArm: { rotation: { pitch: -45, yaw: 0, roll: -10 } },\n  leftLeg: {\n    rotation: { pitch: -90, yaw: 0, roll: 0 },\n    offset: { x: 0, y: -3, z: 4 },\n  },\n  rightLeg: {\n    rotation: { pitch: -90, yaw: 0, roll: 0 },\n    offset: { x: 0, y: -3, z: 4 },\n  },\n};\n\n/**\n * Pointing pose - right arm extended forward\n */\nexport const POSE_POINTING: PoseDefinition = {\n  name: 'pointing',\n  head: { rotation: { pitch: -5, yaw: -10, roll: 0 } },\n  torso: { rotation: { pitch: 0, yaw: -5, roll: 0 } },\n  leftArm: { rotation: { pitch: 0, yaw: 0, roll: 5 } },\n  rightArm: { rotation: { pitch: -90, yaw: -10, roll: 0 } },\n  leftLeg: DEFAULT_POSE,\n  rightLeg: DEFAULT_POSE,\n};\n\n/**\n * Crossed arms pose\n */\nexport const POSE_CROSSED_ARMS: PoseDefinition = {\n  name: 'crossed_arms',\n  head: { rotation: { pitch: 5, yaw: 0, roll: 0 } },\n  torso: DEFAULT_POSE,\n  leftArm: {\n    rotation: { pitch: -50, yaw: 0, roll: 50 },\n    offset: { x: -2, y: -2, z: 2 },\n  },\n  rightArm: {\n    rotation: { pitch: -50, yaw: 0, roll: -50 },\n    offset: { x: 2, y: -2, z: 2 },\n  },\n  leftLeg: DEFAULT_POSE,\n  rightLeg: DEFAULT_POSE,\n};\n\n/**\n * Map of pose names to definitions\n */\nexport const POSES: Record<Exclude<PoseName, 'custom'>, PoseDefinition> = {\n  standing: POSE_STANDING,\n  walking: POSE_WALKING,\n  running: POSE_RUNNING,\n  waving: POSE_WAVING,\n  sitting: POSE_SITTING,\n  pointing: POSE_POINTING,\n  crossed_arms: POSE_CROSSED_ARMS,\n};\n\n/**\n * Get pose definition by name\n */\nexport function getPose(name: PoseName): PoseDefinition | null {\n  if (name === 'custom') return null;\n  return POSES[name] ?? null;\n}\n\n/**\n * Validate custom pose definition\n */\nexport function validatePose(pose: PoseDefinition): boolean {\n  const requiredParts = [\n    'head',\n    'torso',\n    'leftArm',\n    'rightArm',\n    'leftLeg',\n    'rightLeg',\n  ] as const;\n\n  for (const part of requiredParts) {\n    const bodyPart = pose[part];\n    if (!bodyPart || typeof bodyPart !== 'object' || !('rotation' in bodyPart)) {\n      return false;\n    }\n    const rotation = bodyPart.rotation;\n    if (\n      typeof rotation.pitch !== 'number' ||\n      typeof rotation.yaw !== 'number' ||\n      typeof rotation.roll !== 'number'\n    ) {\n      return false;\n    }\n  }\n  return true;\n}\n\n/**\n * Get body part pose from pose definition\n */\nexport function getBodyPartPose(\n  pose: PoseDefinition,\n  part: 'head' | 'torso' | 'leftArm' | 'rightArm' | 'leftLeg' | 'rightLeg'\n): BodyPartPose {\n  return pose[part];\n}\n\n/**\n * Create a custom pose from individual body part configurations\n */\nexport function createCustomPose(\n  head: BodyPartPose,\n  torso: BodyPartPose,\n  leftArm: BodyPartPose,\n  rightArm: BodyPartPose,\n  leftLeg: BodyPartPose,\n  rightLeg: BodyPartPose\n): PoseDefinition {\n  return {\n    name: 'custom',\n    head,\n    torso,\n    leftArm,\n    rightArm,\n    leftLeg,\n    rightLeg,\n  };\n}\n\n/**\n * Interpolate between two poses (for animation)\n */\nexport function interpolatePoses(\n  poseA: PoseDefinition,\n  poseB: PoseDefinition,\n  t: number\n): PoseDefinition {\n  const lerp = (a: number, b: number) => a + (b - a) * t;\n\n  const interpolateRotation = (\n    a: Rotation3D,\n    b: Rotation3D\n  ): Rotation3D => ({\n    pitch: lerp(a.pitch, b.pitch),\n    yaw: lerp(a.yaw, b.yaw),\n    roll: lerp(a.roll, b.roll),\n  });\n\n  const interpolateBodyPart = (\n    a: BodyPartPose,\n    b: BodyPartPose\n  ): BodyPartPose => {\n    const result: BodyPartPose = {\n      rotation: interpolateRotation(a.rotation, b.rotation),\n    };\n    if (a.offset || b.offset) {\n      const offsetA = a.offset ?? { x: 0, y: 0, z: 0 };\n      const offsetB = b.offset ?? { x: 0, y: 0, z: 0 };\n      result.offset = {\n        x: lerp(offsetA.x, offsetB.x),\n        y: lerp(offsetA.y, offsetB.y),\n        z: lerp(offsetA.z, offsetB.z),\n      };\n    }\n    return result;\n  };\n\n  return {\n    name: 'custom',\n    head: interpolateBodyPart(poseA.head, poseB.head),\n    torso: interpolateBodyPart(poseA.torso, poseB.torso),\n    leftArm: interpolateBodyPart(poseA.leftArm, poseB.leftArm),\n    rightArm: interpolateBodyPart(poseA.rightArm, poseB.rightArm),\n    leftLeg: interpolateBodyPart(poseA.leftLeg, poseB.leftLeg),\n    rightLeg: interpolateBodyPart(poseA.rightLeg, poseB.rightLeg),\n  };\n}\n","/**\n * 3D Projection and Vector Math Utilities\n */\n\nimport type { Vector3, Point2D, Rotation3D, ViewConfig } from '../shared/types';\n\n/**\n * Convert degrees to radians\n */\nexport function degToRad(degrees: number): number {\n  return (degrees * Math.PI) / 180;\n}\n\n/**\n * Add two vectors\n */\nexport function addVec3(a: Vector3, b: Vector3): Vector3 {\n  return { x: a.x + b.x, y: a.y + b.y, z: a.z + b.z };\n}\n\n/**\n * Subtract vector b from vector a\n */\nexport function subVec3(a: Vector3, b: Vector3): Vector3 {\n  return { x: a.x - b.x, y: a.y - b.y, z: a.z - b.z };\n}\n\n/**\n * Scale a vector by a scalar\n */\nexport function scaleVec3(v: Vector3, s: number): Vector3 {\n  return { x: v.x * s, y: v.y * s, z: v.z * s };\n}\n\n/**\n * Calculate dot product of two vectors\n */\nexport function dotVec3(a: Vector3, b: Vector3): number {\n  return a.x * b.x + a.y * b.y + a.z * b.z;\n}\n\n/**\n * Calculate cross product of two vectors\n */\nexport function crossVec3(a: Vector3, b: Vector3): Vector3 {\n  return {\n    x: a.y * b.z - a.z * b.y,\n    y: a.z * b.x - a.x * b.z,\n    z: a.x * b.y - a.y * b.x,\n  };\n}\n\n/**\n * Normalize a vector to unit length\n */\nexport function normalizeVec3(v: Vector3): Vector3 {\n  const len = Math.sqrt(v.x * v.x + v.y * v.y + v.z * v.z);\n  if (len === 0) return { x: 0, y: 0, z: 0 };\n  return { x: v.x / len, y: v.y / len, z: v.z / len };\n}\n\n/**\n * Rotate a point around the X axis (pitch)\n */\nexport function rotateX(point: Vector3, angleDeg: number): Vector3 {\n  const rad = degToRad(angleDeg);\n  const cos = Math.cos(rad);\n  const sin = Math.sin(rad);\n  return {\n    x: point.x,\n    y: point.y * cos - point.z * sin,\n    z: point.y * sin + point.z * cos,\n  };\n}\n\n/**\n * Rotate a point around the Y axis (yaw)\n */\nexport function rotateY(point: Vector3, angleDeg: number): Vector3 {\n  const rad = degToRad(angleDeg);\n  const cos = Math.cos(rad);\n  const sin = Math.sin(rad);\n  return {\n    x: point.x * cos + point.z * sin,\n    y: point.y,\n    z: -point.x * sin + point.z * cos,\n  };\n}\n\n/**\n * Rotate a point around the Z axis (roll)\n */\nexport function rotateZ(point: Vector3, angleDeg: number): Vector3 {\n  const rad = degToRad(angleDeg);\n  const cos = Math.cos(rad);\n  const sin = Math.sin(rad);\n  return {\n    x: point.x * cos - point.y * sin,\n    y: point.x * sin + point.y * cos,\n    z: point.z,\n  };\n}\n\n/**\n * Apply Euler rotation (pitch, yaw, roll) to a point\n * Order: Roll -> Pitch -> Yaw (ZXY convention)\n */\nexport function applyRotation(point: Vector3, rotation: Rotation3D): Vector3 {\n  let result = point;\n  result = rotateZ(result, rotation.roll);\n  result = rotateX(result, rotation.pitch);\n  result = rotateY(result, rotation.yaw);\n  return result;\n}\n\n/**\n * Apply rotation around a pivot point\n */\nexport function rotateAroundPivot(\n  point: Vector3,\n  pivot: Vector3,\n  rotation: Rotation3D\n): Vector3 {\n  // Translate to pivot origin\n  const translated = subVec3(point, pivot);\n  // Apply rotation\n  const rotated = applyRotation(translated, rotation);\n  // Translate back\n  return addVec3(rotated, pivot);\n}\n\n/**\n * Apply view transformation (camera angle and elevation)\n * angle=0 shows front of character, angle=90 shows left side, angle=180 shows back\n */\nexport function applyViewTransform(point: Vector3, view: ViewConfig): Vector3 {\n  // Negate angle so positive angles rotate camera around model (not model itself)\n  // This makes angle=0 show the front, angle=90 show the left side\n  let result = rotateY(point, -view.angle);\n  // Then rotate around X axis (elevation) - negative to tilt camera up when elevation > 0\n  result = rotateX(result, -view.elevation);\n  // Apply zoom\n  result = scaleVec3(result, view.zoom);\n  return result;\n}\n\n/**\n * Project a 3D point to 2D using orthographic projection\n * Returns screen coordinates where Y is flipped (screen Y increases downward)\n */\nexport function projectOrthographic(\n  point: Vector3,\n  canvasWidth: number,\n  canvasHeight: number,\n  scale: number = 1\n): Point2D {\n  const centerX = canvasWidth / 2;\n  const centerY = canvasHeight / 2;\n\n  return {\n    x: centerX + point.x * scale,\n    y: centerY - point.y * scale, // Flip Y for screen coordinates\n  };\n}\n\n/**\n * Project a 3D point to 2D using perspective projection\n */\nexport function projectPerspective(\n  point: Vector3,\n  canvasWidth: number,\n  canvasHeight: number,\n  fov: number = 50,\n  distance: number = 100\n): Point2D {\n  const centerX = canvasWidth / 2;\n  const centerY = canvasHeight / 2;\n\n  const fovRad = degToRad(fov);\n  const scale = distance / (distance + point.z);\n\n  return {\n    x: centerX + point.x * scale * (canvasWidth / (2 * Math.tan(fovRad / 2))),\n    y: centerY - point.y * scale * (canvasWidth / (2 * Math.tan(fovRad / 2))),\n  };\n}\n\n/**\n * Calculate the average depth (Z) of multiple points\n */\nexport function calculateAverageDepth(points: Vector3[]): number {\n  if (points.length === 0) return 0;\n  const sum = points.reduce((acc, p) => acc + p.z, 0);\n  return sum / points.length;\n}\n\n/**\n * Calculate face normal from 3 vertices (counter-clockwise winding)\n */\nexport function calculateFaceNormal(\n  v0: Vector3,\n  v1: Vector3,\n  v2: Vector3\n): Vector3 {\n  const edge1 = subVec3(v1, v0);\n  const edge2 = subVec3(v2, v0);\n  return normalizeVec3(crossVec3(edge1, edge2));\n}\n\n/**\n * Check if a face is visible from the camera (back-face culling)\n * Returns true if the face is facing toward the camera\n */\nexport function isFaceVisible(normal: Vector3, viewDirection: Vector3): boolean {\n  return dotVec3(normal, viewDirection) < 0;\n}\n\n/**\n * Transform all vertices of a quad and return projected 2D points\n */\nexport function transformAndProjectQuad(\n  vertices: [Vector3, Vector3, Vector3, Vector3],\n  position: Vector3,\n  pivot: Vector3,\n  rotation: Rotation3D,\n  view: ViewConfig,\n  canvasWidth: number,\n  canvasHeight: number,\n  scale: number\n): {\n  points: [Point2D, Point2D, Point2D, Point2D];\n  transformedVertices: [Vector3, Vector3, Vector3, Vector3];\n  depth: number;\n} {\n  const transformedVertices = vertices.map((vertex) => {\n    // 1. Apply local rotation around pivot\n    let point = rotateAroundPivot(vertex, pivot, rotation);\n    // 2. Translate to world position\n    point = addVec3(point, position);\n    // 3. Apply view transformation\n    point = applyViewTransform(point, view);\n    return point;\n  }) as [Vector3, Vector3, Vector3, Vector3];\n\n  const points = transformedVertices.map((v) =>\n    projectOrthographic(v, canvasWidth, canvasHeight, scale)\n  ) as [Point2D, Point2D, Point2D, Point2D];\n\n  const depth = calculateAverageDepth(transformedVertices);\n\n  return { points, transformedVertices, depth };\n}\n","/**\n * Texture Mapping Utilities\n * Handles extraction and transformation of texture regions from skin images\n */\n\nimport type { SkinRegion, Point2D } from '../shared/types';\n\n/**\n * Extract a rectangular region from skin pixel data\n */\nexport function extractTextureRegion(\n  skinData: Buffer,\n  skinWidth: number,\n  region: SkinRegion\n): Buffer {\n  const { x, y, width, height } = region;\n  const regionData = Buffer.alloc(width * height * 4); // RGBA\n\n  for (let row = 0; row < height; row++) {\n    for (let col = 0; col < width; col++) {\n      const srcIdx = ((y + row) * skinWidth + (x + col)) * 4;\n      const dstIdx = (row * width + col) * 4;\n\n      regionData[dstIdx] = skinData[srcIdx]; // R\n      regionData[dstIdx + 1] = skinData[srcIdx + 1]; // G\n      regionData[dstIdx + 2] = skinData[srcIdx + 2]; // B\n      regionData[dstIdx + 3] = skinData[srcIdx + 3]; // A\n    }\n  }\n\n  return regionData;\n}\n\n/**\n * Check if a texture region has any visible (non-transparent) pixels\n */\nexport function hasVisiblePixels(textureData: Buffer): boolean {\n  for (let i = 3; i < textureData.length; i += 4) {\n    if (textureData[i] > 0) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * Calculate perspective transformation matrix for a quad\n * Maps source rectangle to destination quadrilateral\n */\nexport function calculatePerspectiveMatrix(\n  srcWidth: number,\n  srcHeight: number,\n  dstPoints: [Point2D, Point2D, Point2D, Point2D]\n): number[] {\n  // Source corners (rectangle)\n  const sx0 = 0,\n    sy0 = 0;\n  const sx1 = srcWidth,\n    sy1 = 0;\n  const sx2 = srcWidth,\n    sy2 = srcHeight;\n  const sx3 = 0,\n    sy3 = srcHeight;\n\n  // Destination corners (quadrilateral)\n  const [d0, d1, d2, d3] = dstPoints;\n  const dx0 = d0.x,\n    dy0 = d0.y;\n  const dx1 = d1.x,\n    dy1 = d1.y;\n  const dx2 = d2.x,\n    dy2 = d2.y;\n  const dx3 = d3.x,\n    dy3 = d3.y;\n\n  // Calculate perspective transformation coefficients\n  // Using the standard 8-parameter perspective transform\n\n  const denom =\n    (sx0 - sx1 + sx2 - sx3) * (sy1 - sy2) - (sx1 - sx2) * (sy0 - sy1 + sy2 - sy3);\n\n  if (Math.abs(denom) < 1e-10) {\n    // Fallback to affine transformation\n    return calculateAffineMatrix(srcWidth, srcHeight, dstPoints);\n  }\n\n  const a13 =\n    ((dx0 - dx1 + dx2 - dx3) * (sy1 - sy2) - (dx1 - dx2) * (sy0 - sy1 + sy2 - sy3)) /\n    denom;\n  const a23 =\n    ((sx0 - sx1 + sx2 - sx3) * (dx1 - dx2) - (dx0 - dx1 + dx2 - dx3) * (sx1 - sx2)) /\n    denom;\n\n  const a11 = dx1 - dx0 + a13 * dx1;\n  const a21 = dx3 - dx0 + a23 * dx3;\n  const a31 = dx0;\n\n  const a12 = dy1 - dy0 + a13 * dy1;\n  const a22 = dy3 - dy0 + a23 * dy3;\n  const a32 = dy0;\n\n  // Return 3x3 matrix coefficients [a11, a12, a13, a21, a22, a23, a31, a32, 1]\n  return [\n    a11 / srcWidth,\n    a12 / srcWidth,\n    a13 / srcWidth,\n    a21 / srcHeight,\n    a22 / srcHeight,\n    a23 / srcHeight,\n    a31,\n    a32,\n    1,\n  ];\n}\n\n/**\n * Calculate affine transformation matrix (fallback for degenerate cases)\n */\nfunction calculateAffineMatrix(\n  srcWidth: number,\n  srcHeight: number,\n  dstPoints: [Point2D, Point2D, Point2D, Point2D]\n): number[] {\n  const [d0, d1, , d3] = dstPoints;\n\n  // Simple affine: scale and translate\n  const scaleX = (d1.x - d0.x) / srcWidth;\n  const scaleY = (d3.y - d0.y) / srcHeight;\n\n  return [scaleX, 0, 0, 0, scaleY, 0, d0.x, d0.y, 1];\n}\n\n/**\n * Apply perspective transformation to get source coordinates\n * Given destination coordinates, returns the corresponding source coordinates\n */\nexport function inversePerspectiveTransform(\n  matrix: number[],\n  dstX: number,\n  dstY: number,\n  srcWidth: number,\n  srcHeight: number\n): { x: number; y: number } | null {\n  // Invert the perspective transformation\n  const [a, b, c, d, e, f, g, h] = matrix;\n\n  // For perspective transform: dst = (ax + by + g, dx + ey + h) / (cx + fy + 1)\n  // We need to solve for source coordinates\n\n  // This is a simplification - for rendering, we'll use forward mapping\n  const w = c * dstX + f * dstY + 1;\n  if (Math.abs(w) < 1e-10) return null;\n\n  const srcX = (dstX - g) / (a || 1);\n  const srcY = (dstY - h) / (e || 1);\n\n  if (srcX < 0 || srcX >= srcWidth || srcY < 0 || srcY >= srcHeight) {\n    return null;\n  }\n\n  return { x: srcX, y: srcY };\n}\n\n/**\n * Bilinear interpolation for texture sampling\n */\nexport function sampleTextureBilinear(\n  textureData: Buffer,\n  texWidth: number,\n  texHeight: number,\n  u: number,\n  v: number\n): [number, number, number, number] {\n  // Clamp coordinates\n  const x = Math.max(0, Math.min(texWidth - 1, u));\n  const y = Math.max(0, Math.min(texHeight - 1, v));\n\n  const x0 = Math.floor(x);\n  const y0 = Math.floor(y);\n  const x1 = Math.min(x0 + 1, texWidth - 1);\n  const y1 = Math.min(y0 + 1, texHeight - 1);\n\n  const fx = x - x0;\n  const fy = y - y0;\n\n  // Get pixel values at four corners\n  const getPixel = (px: number, py: number): [number, number, number, number] => {\n    const idx = (py * texWidth + px) * 4;\n    return [\n      textureData[idx] || 0,\n      textureData[idx + 1] || 0,\n      textureData[idx + 2] || 0,\n      textureData[idx + 3] || 0,\n    ];\n  };\n\n  const p00 = getPixel(x0, y0);\n  const p10 = getPixel(x1, y0);\n  const p01 = getPixel(x0, y1);\n  const p11 = getPixel(x1, y1);\n\n  // Bilinear interpolation\n  const lerp = (a: number, b: number, t: number) => a + (b - a) * t;\n\n  return [\n    Math.round(lerp(lerp(p00[0], p10[0], fx), lerp(p01[0], p11[0], fx), fy)),\n    Math.round(lerp(lerp(p00[1], p10[1], fx), lerp(p01[1], p11[1], fx), fy)),\n    Math.round(lerp(lerp(p00[2], p10[2], fx), lerp(p01[2], p11[2], fx), fy)),\n    Math.round(lerp(lerp(p00[3], p10[3], fx), lerp(p01[3], p11[3], fx), fy)),\n  ];\n}\n\n/**\n * Nearest-neighbor texture sampling (for pixelated Minecraft look)\n */\nexport function sampleTextureNearest(\n  textureData: Buffer,\n  texWidth: number,\n  texHeight: number,\n  u: number,\n  v: number\n): [number, number, number, number] {\n  const x = Math.max(0, Math.min(texWidth - 1, Math.floor(u)));\n  const y = Math.max(0, Math.min(texHeight - 1, Math.floor(v)));\n\n  const idx = (y * texWidth + x) * 4;\n  return [\n    textureData[idx] || 0,\n    textureData[idx + 1] || 0,\n    textureData[idx + 2] || 0,\n    textureData[idx + 3] || 0,\n  ];\n}\n\n/**\n * Calculate bounding box for a set of 2D points\n */\nexport function calculateBoundingBox(\n  points: Point2D[]\n): { minX: number; minY: number; maxX: number; maxY: number } {\n  let minX = Infinity;\n  let minY = Infinity;\n  let maxX = -Infinity;\n  let maxY = -Infinity;\n\n  for (const p of points) {\n    minX = Math.min(minX, p.x);\n    minY = Math.min(minY, p.y);\n    maxX = Math.max(maxX, p.x);\n    maxY = Math.max(maxY, p.y);\n  }\n\n  return { minX, minY, maxX, maxY };\n}\n\n/**\n * Check if a point is inside a quadrilateral using cross product method\n */\nexport function isPointInQuad(\n  point: Point2D,\n  quad: [Point2D, Point2D, Point2D, Point2D]\n): boolean {\n  const [p0, p1, p2, p3] = quad;\n\n  // Check if point is on the same side of all edges\n  const cross = (a: Point2D, b: Point2D, c: Point2D) =>\n    (b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x);\n\n  const d1 = cross(p0, p1, point);\n  const d2 = cross(p1, p2, point);\n  const d3 = cross(p2, p3, point);\n  const d4 = cross(p3, p0, point);\n\n  const hasNeg = d1 < 0 || d2 < 0 || d3 < 0 || d4 < 0;\n  const hasPos = d1 > 0 || d2 > 0 || d3 > 0 || d4 > 0;\n\n  return !(hasNeg && hasPos);\n}\n\n/**\n * Calculate UV coordinates for a point in a quad using bilinear interpolation\n * Quad vertices are ordered: [top-left, top-right, bottom-right, bottom-left]\n * UV mapping: top-left=(0,0), top-right=(1,0), bottom-right=(1,1), bottom-left=(0,1)\n */\nexport function getBarycentricCoords(\n  point: Point2D,\n  quad: [Point2D, Point2D, Point2D, Point2D]\n): { u: number; v: number } {\n  const [p0, p1, p2, p3] = quad;\n\n  // For near-rectangular quads (common case after orthographic projection),\n  // use a simpler and more robust approach\n\n  // Calculate the quad's basis vectors\n  // Top edge: p0 -> p1 (u direction at v=0)\n  // Left edge: p0 -> p3 (v direction at u=0)\n  const topEdgeX = p1.x - p0.x;\n  const topEdgeY = p1.y - p0.y;\n  const leftEdgeX = p3.x - p0.x;\n  const leftEdgeY = p3.y - p0.y;\n\n  // Point relative to top-left corner\n  const px = point.x - p0.x;\n  const py = point.y - p0.y;\n\n  // Solve using 2x2 linear system (works well for parallelograms/rectangles):\n  // px = u * topEdgeX + v * leftEdgeX\n  // py = u * topEdgeY + v * leftEdgeY\n\n  const det = topEdgeX * leftEdgeY - topEdgeY * leftEdgeX;\n\n  if (Math.abs(det) < 1e-10) {\n    // Degenerate quad (edges are parallel), fallback\n    return { u: 0.5, v: 0.5 };\n  }\n\n  // Cramer's rule\n  const u = (px * leftEdgeY - py * leftEdgeX) / det;\n  const v = (topEdgeX * py - topEdgeY * px) / det;\n\n  return {\n    u: Math.max(0, Math.min(1, u)),\n    v: Math.max(0, Math.min(1, v)),\n  };\n}\n","/**\n * 3D Full Body Renderer\n * Renders Minecraft character models with pose support using @napi-rs/canvas\n */\n\nimport type {\n  FullBodyOptions,\n  FullBodyResult,\n  SkinFormat,\n  ArmModel,\n  PoseDefinition,\n  PoseName,\n  ViewConfig,\n  Vector3,\n  Point2D,\n  ProjectedQuad,\n  BodyPart,\n  CubeFace,\n} from '../shared/types';\nimport { DEFAULT_FULLBODY_OPTIONS, DEFAULT_VIEW } from '../shared/constants';\nimport { detectSkinFormat } from './skin-parser';\nimport { createCharacterMeshes, type BodyPartMesh } from '../3d/geometry';\nimport { getPose, POSE_STANDING } from '../3d/poses';\nimport {\n  applyRotation,\n  addVec3,\n  subVec3,\n  rotateAroundPivot,\n  applyViewTransform,\n  projectOrthographic,\n  calculateAverageDepth,\n  dotVec3,\n} from '../3d/projection';\nimport {\n  extractTextureRegion,\n  hasVisiblePixels,\n  sampleTextureNearest,\n  calculateBoundingBox,\n  getBarycentricCoords,\n  isPointInQuad,\n} from '../3d/texture-mapper';\n\n/**\n * Render a 3D full body avatar from skin texture data\n */\nexport async function renderFullBody(\n  skinBuffer: Buffer,\n  options: FullBodyOptions = {}\n): Promise<FullBodyResult> {\n  // Import canvas dynamically\n  const { createCanvas } = await import('@napi-rs/canvas');\n\n  // Import sharp for skin data extraction\n  const sharp = (await import('sharp')).default;\n\n  // Get skin metadata\n  const skinImage = sharp(skinBuffer);\n  const metadata = await skinImage.metadata();\n\n  if (!metadata.width || !metadata.height) {\n    throw new Error('Invalid skin texture: unable to read dimensions');\n  }\n\n  // Detect skin format\n  const skinFormat = detectSkinFormat(metadata.width, metadata.height);\n\n  // Get raw pixel data from skin\n  const skinData = await skinImage.ensureAlpha().raw().toBuffer();\n\n  // Merge options with defaults\n  const opts = {\n    width: options.width ?? DEFAULT_FULLBODY_OPTIONS.width,\n    height: options.height ?? DEFAULT_FULLBODY_OPTIONS.height,\n    includeOverlay: options.includeOverlay ?? DEFAULT_FULLBODY_OPTIONS.includeOverlay,\n    view: { ...DEFAULT_VIEW, ...options.view } as ViewConfig,\n    background: options.background ?? DEFAULT_FULLBODY_OPTIONS.background,\n    shadow: options.shadow ?? DEFAULT_FULLBODY_OPTIONS.shadow,\n  };\n\n  // Determine arm model\n  const armModel: ArmModel = options.armModel ?? 'classic';\n\n  // Get pose\n  let pose: PoseDefinition;\n  let poseName: PoseName;\n\n  if (typeof options.pose === 'string') {\n    pose = getPose(options.pose) ?? POSE_STANDING;\n    poseName = options.pose;\n  } else if (options.pose && typeof options.pose === 'object') {\n    pose = options.pose;\n    poseName = 'custom';\n  } else {\n    pose = POSE_STANDING;\n    poseName = 'standing';\n  }\n\n  // Create canvas\n  const canvas = createCanvas(opts.width, opts.height);\n  const ctx = canvas.getContext('2d');\n\n  // Clear canvas with background or transparent\n  if (opts.background) {\n    ctx.fillStyle = opts.background;\n    ctx.fillRect(0, 0, opts.width, opts.height);\n  }\n\n  // Create character meshes\n  const meshes = createCharacterMeshes(armModel, opts.includeOverlay && skinFormat === 'modern');\n\n  // Calculate scale to fit character in canvas\n  // Character height is approximately 32 units (2 blocks)\n  const characterHeight = 32;\n  const scale = (opts.height * 0.75) / characterHeight;\n\n  // Model center offset - the model goes from y=0 (feet) to y~28 (head top)\n  // We need to shift it so the center (~y=14) is at the origin for proper centering\n  const modelCenterOffset: Vector3 = { x: 0, y: -14, z: 0 };\n\n  // Collect all projected quads for sorting\n  const quads: ProjectedQuad[] = [];\n\n  // Camera view direction (looking at -Z)\n  const viewDirection: Vector3 = { x: 0, y: 0, z: -1 };\n\n  // Process each mesh\n  for (const mesh of meshes) {\n    // Get pose for this body part\n    const bodyPartPose = pose[mesh.part as keyof PoseDefinition] as {\n      rotation: { pitch: number; yaw: number; roll: number };\n      offset?: Vector3;\n    };\n\n    if (!bodyPartPose || !bodyPartPose.rotation) continue;\n\n    // Calculate position with pose offset\n    const poseOffset = bodyPartPose.offset ?? { x: 0, y: 0, z: 0 };\n    const worldPosition = addVec3(mesh.position, poseOffset);\n\n    // Process each face\n    for (const face of mesh.faces) {\n      // Transform vertices\n      const transformedVertices = face.vertices.map((vertex) => {\n        // 1. Apply body part rotation around pivot\n        let point = rotateAroundPivot(vertex, mesh.pivot, bodyPartPose.rotation);\n        // 2. Translate to world position\n        point = addVec3(point, worldPosition);\n        // 3. Center the model (shift so model center is at origin)\n        point = addVec3(point, modelCenterOffset);\n        // 4. Apply view transformation\n        point = applyViewTransform(point, opts.view);\n        return point;\n      }) as [Vector3, Vector3, Vector3, Vector3];\n\n      // Calculate transformed normal for back-face culling\n      // Vertices are ordered: [top-left, top-right, bottom-right, bottom-left]\n      // edge1 = v1 - v0 = right direction\n      // edge2 = v3 - v0 = down direction\n      // For outward-facing normal, we need edge2  edge1 (down  right = toward viewer)\n      const edge1 = subVec3(transformedVertices[1], transformedVertices[0]);\n      const edge2 = subVec3(transformedVertices[3], transformedVertices[0]);\n      // Cross product: edge2  edge1\n      const transformedNormal: Vector3 = {\n        x: edge2.y * edge1.z - edge2.z * edge1.y,\n        y: edge2.z * edge1.x - edge2.x * edge1.z,\n        z: edge2.x * edge1.y - edge2.y * edge1.x,\n      };\n\n      // Back-face culling - skip faces pointing away from camera\n      if (dotVec3(transformedNormal, viewDirection) >= 0) {\n        continue;\n      }\n\n      // Project to 2D\n      const projectedPoints = transformedVertices.map((v) =>\n        projectOrthographic(v, opts.width, opts.height, scale)\n      ) as [Point2D, Point2D, Point2D, Point2D];\n\n      // Calculate depth for sorting\n      const depth = calculateAverageDepth(transformedVertices);\n\n      quads.push({\n        points: projectedPoints,\n        textureRegion: face.uv,\n        depth,\n        isOverlay: mesh.isOverlay,\n        bodyPart: mesh.part,\n        face: face.name,\n      });\n    }\n  }\n\n  // Sort quads by depth (painter's algorithm - back to front)\n  quads.sort((a, b) => {\n    // First sort by depth\n    if (Math.abs(a.depth - b.depth) > 0.01) {\n      return b.depth - a.depth;\n    }\n    // Then base layers before overlays\n    if (a.isOverlay !== b.isOverlay) {\n      return a.isOverlay ? 1 : -1;\n    }\n    return 0;\n  });\n\n  // Track which overlays have visible content\n  let hasVisibleOverlay = false;\n\n  // Render each quad\n  for (const quad of quads) {\n    // Extract texture region from skin\n    const textureData = extractTextureRegion(\n      skinData,\n      metadata.width,\n      quad.textureRegion\n    );\n\n    // Skip empty overlay textures\n    if (quad.isOverlay && !hasVisiblePixels(textureData)) {\n      continue;\n    }\n\n    if (quad.isOverlay) {\n      hasVisibleOverlay = true;\n    }\n\n    // Render the textured quad\n    renderTexturedQuad(\n      ctx,\n      quad.points,\n      textureData,\n      quad.textureRegion.width,\n      quad.textureRegion.height\n    );\n  }\n\n  // Get PNG buffer\n  const pngBuffer = canvas.toBuffer('image/png');\n\n  return {\n    data: pngBuffer,\n    contentType: 'image/png',\n    usedFallback: false,\n    skinFormat,\n    armModel,\n    pose: poseName,\n    hasOverlay: hasVisibleOverlay,\n  };\n}\n\n/**\n * Render a textured quadrilateral onto the canvas\n */\nfunction renderTexturedQuad(\n  ctx: CanvasRenderingContext2D,\n  points: [Point2D, Point2D, Point2D, Point2D],\n  textureData: Buffer,\n  texWidth: number,\n  texHeight: number\n): void {\n  // Calculate bounding box\n  const bbox = calculateBoundingBox(points);\n  const minX = Math.floor(bbox.minX);\n  const minY = Math.floor(bbox.minY);\n  const maxX = Math.ceil(bbox.maxX);\n  const maxY = Math.ceil(bbox.maxY);\n\n  // Skip if completely outside canvas\n  const canvasWidth = ctx.canvas.width;\n  const canvasHeight = ctx.canvas.height;\n  if (maxX < 0 || minX >= canvasWidth || maxY < 0 || minY >= canvasHeight) {\n    return;\n  }\n\n  // Clamp to canvas bounds\n  const startX = Math.max(0, minX);\n  const startY = Math.max(0, minY);\n  const endX = Math.min(canvasWidth, maxX);\n  const endY = Math.min(canvasHeight, maxY);\n\n  // Create image data for the bounding box region\n  const width = endX - startX;\n  const height = endY - startY;\n\n  if (width <= 0 || height <= 0) return;\n\n  const imageData = ctx.getImageData(startX, startY, width, height);\n  const data = imageData.data;\n\n  // Render each pixel\n  for (let y = startY; y < endY; y++) {\n    for (let x = startX; x < endX; x++) {\n      const point: Point2D = { x, y };\n\n      // Check if point is inside the quad\n      if (!isPointInQuad(point, points)) {\n        continue;\n      }\n\n      // Get barycentric coordinates for texture mapping\n      const { u, v } = getBarycentricCoords(point, points);\n\n      // Sample texture\n      const texX = u * (texWidth - 1);\n      const texY = v * (texHeight - 1);\n      const [r, g, b, a] = sampleTextureNearest(\n        textureData,\n        texWidth,\n        texHeight,\n        texX,\n        texY\n      );\n\n      // Skip fully transparent pixels\n      if (a === 0) continue;\n\n      // Calculate pixel index in image data\n      const idx = ((y - startY) * width + (x - startX)) * 4;\n\n      // Alpha blending\n      const srcAlpha = a / 255;\n      const dstAlpha = data[idx + 3] / 255;\n      const outAlpha = srcAlpha + dstAlpha * (1 - srcAlpha);\n\n      if (outAlpha > 0) {\n        data[idx] = (r * srcAlpha + data[idx] * dstAlpha * (1 - srcAlpha)) / outAlpha;\n        data[idx + 1] =\n          (g * srcAlpha + data[idx + 1] * dstAlpha * (1 - srcAlpha)) / outAlpha;\n        data[idx + 2] =\n          (b * srcAlpha + data[idx + 2] * dstAlpha * (1 - srcAlpha)) / outAlpha;\n        data[idx + 3] = outAlpha * 255;\n      }\n    }\n  }\n\n  // Put the modified image data back\n  ctx.putImageData(imageData, startX, startY);\n}\n\n// Type declaration for canvas context\ntype CanvasRenderingContext2D = ReturnType<\n  Awaited<ReturnType<typeof import('@napi-rs/canvas')['createCanvas']>>['getContext']\n>;\n","/**\n * Core Avatar Generation\n */\n\nimport type {\n  AvatarOptions,\n  AvatarResult,\n  FullBodyOptions,\n  FullBodyResult,\n  ArmModel,\n} from '../shared/types';\nimport { DEFAULT_OPTIONS, DEFAULT_FULLBODY_OPTIONS } from '../shared/constants';\nimport { validateUuid } from '../shared/utils';\nimport { fetchMojangProfile, extractSkinInfo, fetchSkinTexture } from './mojang-api';\nimport { renderAvatar } from './renderer';\nimport { renderFullBody } from './renderer-3d';\n\n/**\n * Generate Minecraft avatar from UUID\n *\n * @param uuid - Minecraft player UUID\n * @param options - Avatar generation options\n * @returns Avatar result with image data\n *\n * @example\n * ```typescript\n * import { generateAvatar } from '@bafv4/mcavatar';\n *\n * const result = await generateAvatar('uuid-here', { size: 64 });\n * // result.data is a Buffer containing PNG image\n * ```\n */\nexport async function generateAvatar(\n  uuid: string,\n  options: AvatarOptions = {}\n): Promise<AvatarResult> {\n  const opts = { ...DEFAULT_OPTIONS, ...options };\n\n  try {\n    // Fetch skin from Mojang API\n    const cleanUuid = validateUuid(uuid);\n    const profile = await fetchMojangProfile(cleanUuid);\n    const skinInfo = extractSkinInfo(profile);\n    const skinBuffer = await fetchSkinTexture(skinInfo.skinUrl);\n\n    return await renderAvatar(skinBuffer, opts);\n  } catch (error) {\n    // Use fallback if enabled and different from requested UUID\n    if (opts.fallbackUuid && opts.fallbackUuid !== uuid) {\n      try {\n        const fallbackProfile = await fetchMojangProfile(opts.fallbackUuid);\n        const fallbackSkinInfo = extractSkinInfo(fallbackProfile);\n        const fallbackSkinBuffer = await fetchSkinTexture(fallbackSkinInfo.skinUrl);\n\n        const result = await renderAvatar(fallbackSkinBuffer, opts);\n        return { ...result, usedFallback: true };\n      } catch {\n        // Re-throw original error if fallback also fails\n        throw error;\n      }\n    }\n\n    throw error;\n  }\n}\n\n/**\n * Generate 3D full-body Minecraft avatar from UUID\n *\n * @param uuid - Minecraft player UUID\n * @param options - Full body generation options\n * @returns Full body result with image data\n *\n * @example\n * ```typescript\n * import { generateFullBody } from '@bafv4/mcavatar';\n *\n * // Simple usage\n * const result = await generateFullBody('uuid-here');\n *\n * // With options\n * const result = await generateFullBody('uuid-here', {\n *   width: 256,\n *   height: 512,\n *   pose: 'waving',\n *   view: { angle: 45, elevation: 15 },\n * });\n *\n * // Custom pose\n * const result = await generateFullBody('uuid-here', {\n *   pose: {\n *     name: 'custom',\n *     head: { rotation: { pitch: -10, yaw: 20, roll: 0 } },\n *     torso: { rotation: { pitch: 0, yaw: 0, roll: 0 } },\n *     leftArm: { rotation: { pitch: 45, yaw: 0, roll: 10 } },\n *     rightArm: { rotation: { pitch: -30, yaw: 0, roll: -5 } },\n *     leftLeg: { rotation: { pitch: 0, yaw: 0, roll: 0 } },\n *     rightLeg: { rotation: { pitch: 0, yaw: 0, roll: 0 } },\n *   },\n * });\n * ```\n */\nexport async function generateFullBody(\n  uuid: string,\n  options: FullBodyOptions = {}\n): Promise<FullBodyResult> {\n  const opts = {\n    ...DEFAULT_FULLBODY_OPTIONS,\n    ...options,\n    view: { ...DEFAULT_FULLBODY_OPTIONS.view, ...options.view },\n  };\n\n  try {\n    // Fetch skin from Mojang API\n    const cleanUuid = validateUuid(uuid);\n    const profile = await fetchMojangProfile(cleanUuid);\n    const skinInfo = extractSkinInfo(profile);\n    const skinArrayBuffer = await fetchSkinTexture(skinInfo.skinUrl);\n    const skinBuffer = Buffer.from(skinArrayBuffer);\n\n    // Determine arm model from skin info if not specified\n    const armModel: ArmModel = options.armModel ?? (skinInfo.isSlim ? 'slim' : 'classic');\n\n    return await renderFullBody(skinBuffer, { ...opts, armModel });\n  } catch (error) {\n    // Use fallback if enabled and different from requested UUID\n    if (opts.fallbackUuid && opts.fallbackUuid !== uuid) {\n      try {\n        const fallbackProfile = await fetchMojangProfile(opts.fallbackUuid);\n        const fallbackSkinInfo = extractSkinInfo(fallbackProfile);\n        const fallbackArrayBuffer = await fetchSkinTexture(fallbackSkinInfo.skinUrl);\n        const fallbackSkinBuffer = Buffer.from(fallbackArrayBuffer);\n\n        const armModel: ArmModel =\n          options.armModel ?? (fallbackSkinInfo.isSlim ? 'slim' : 'classic');\n\n        const result = await renderFullBody(fallbackSkinBuffer, { ...opts, armModel });\n        return { ...result, usedFallback: true };\n      } catch {\n        // Re-throw original error if fallback also fails\n        throw error;\n      }\n    }\n\n    throw error;\n  }\n}\n\n// Re-export types and utilities\nexport type {\n  AvatarOptions,\n  AvatarResult,\n  SkinFormat,\n  MinecraftAvatarProps,\n  // 3D types\n  FullBodyOptions,\n  FullBodyResult,\n  MinecraftFullBodyProps,\n  PoseName,\n  PoseDefinition,\n  BodyPartPose,\n  Rotation3D,\n  Vector3,\n  ViewConfig,\n  ArmModel,\n  BodyPart,\n} from '../shared/types';\nexport { STEVE_UUID, DEFAULT_OPTIONS, DEFAULT_FULLBODY_OPTIONS } from '../shared/constants';\nexport { validateUuid, formatUuid } from '../shared/utils';\n\n// Re-export pose utilities\nexport { POSES, getPose, validatePose, createCustomPose } from '../3d/poses';\n"],"mappings":"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","names":["hasVisibleOverlay"]}